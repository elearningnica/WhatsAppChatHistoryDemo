{"version":3,"file":"whatsapp-chat-parser.min.js","sources":["../src/utils.ts","../src/date.ts","../src/time.ts","../src/parser.ts","../src/index.ts"],"sourcesContent":["/**\n * Checks that the number at a certain index of an array is greater than a\n * certain value.\n */\nfunction indexAboveValue(index: number, value: number) {\n  return (array: number[]): boolean => array[index] > value;\n}\n\n/**\n * Returns `true` for a negative number, `false` otherwise.\n *\n * `0` and `-0` are considered positive.\n */\nfunction isNegative(number: number): boolean {\n  return number < 0;\n}\n\n/**\n * Takes an array of arrays and an index and groups the inner arrays by the\n * value at the index provided.\n * @see `utils.test.ts` for a better understanding of this function.\n */\nfunction groupArrayByValueAtIndex<T extends unknown[]>(\n  array: T[],\n  index: number,\n): T[][] {\n  return Object.values(\n    array.reduce((obj: { [key: string]: T[] }, item) => {\n      /*\n       * Keys that are numbers (even strings containing a number) get sorted\n       * when using `Object.values()`.\n       * Adding a prefix avoids this issue.\n       */\n      const key = `_${item[index]}`;\n\n      if (!obj[key]) obj[key] = [];\n\n      obj[key].push(item);\n\n      return obj;\n    }, {}),\n  );\n}\n\nexport { indexAboveValue, isNegative, groupArrayByValueAtIndex };\n","import { indexAboveValue, isNegative, groupArrayByValueAtIndex } from './utils';\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if numbers go above\n * `12`.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction checkAbove12(numericDates: number[][]): boolean | null {\n  const daysFirst = numericDates.some(indexAboveValue(0, 12));\n\n  if (daysFirst) return true;\n\n  const daysSecond = numericDates.some(indexAboveValue(1, 12));\n\n  if (daysSecond) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if a set of numbers\n * during the same year decrease at some point.\n *\n * If it does it's probably the days since months can only increase in a given\n * year.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction checkDecreasing(numericDates: number[][]): boolean | null {\n  const datesByYear = groupArrayByValueAtIndex(numericDates, 2);\n  const results = datesByYear.map(dates => {\n    const daysFirst = dates.slice(1).some((date, i) => {\n      const [first1] = dates[i];\n      const [first2] = date;\n\n      return isNegative(first2 - first1);\n    });\n\n    if (daysFirst) return true;\n\n    const daysSecond = dates.slice(1).some((date, i) => {\n      const [, second1] = dates[i];\n      const [, second2] = date;\n\n      return isNegative(second2 - second1);\n    });\n\n    if (daysSecond) return false;\n\n    return null;\n  });\n\n  const anyTrue = results.some(value => value === true);\n\n  if (anyTrue) return true;\n\n  const anyFalse = results.some(value => value === false);\n\n  if (anyFalse) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by looking at which number changes\n * more frequently.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction changeFrequencyAnalysis(numericDates: number[][]): boolean | null {\n  const diffs = numericDates\n    .slice(1)\n    .map((date, i) => date.map((num, j) => Math.abs(numericDates[i][j] - num)));\n  const [first, second] = diffs.reduce(\n    (total, diff) => {\n      const [first1, second1] = total;\n      const [first2, second2] = diff;\n\n      return [first1 + first2, second1 + second2];\n    },\n    [0, 0],\n  );\n\n  if (first > second) return true;\n  if (first < second) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by running the dates through various\n * checks.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction daysBeforeMonths(numericDates: number[][]): boolean | null {\n  const firstCheck = checkAbove12(numericDates);\n\n  if (firstCheck !== null) return firstCheck;\n\n  const secondCheck = checkDecreasing(numericDates);\n\n  if (secondCheck !== null) return secondCheck;\n\n  return changeFrequencyAnalysis(numericDates);\n}\n\n/**\n * Takes `year`, `month` and `day` as strings and pads them to `4`, `2`, `2`\n * digits respectively.\n */\nfunction normalizeDate(\n  year: string,\n  month: string,\n  day: string,\n): [string, string, string] {\n  return [\n    // 2 digit years are assumed to be in the 2000-2099 range\n    year.padStart(4, '2000'),\n    month.padStart(2, '0'),\n    day.padStart(2, '0'),\n  ];\n}\n\n/**\n * Pushes the longest number in a date to the end, if there is one. Necessary to\n * ensure the year is the last number.\n */\nfunction orderDateComponents(date: string): [string, string, string] {\n  const regexSplitDate = /[-/.] ?/;\n  const [a, b, c] = date.split(regexSplitDate);\n  const maxLength = Math.max(a.length, b.length, c.length);\n\n  if (c.length === maxLength) return [a, b, c];\n  if (b.length === maxLength) return [a, c, b];\n  return [b, c, a];\n}\n\nexport {\n  checkAbove12,\n  checkDecreasing,\n  changeFrequencyAnalysis,\n  daysBeforeMonths,\n  normalizeDate,\n  orderDateComponents,\n};\n","const regexSplitTime = /[:.]/;\n\n/**\n * Converts time from 12 hour format to 24 hour format.\n *\n * Reference:\n * {@link https://stackoverflow.com/a/40197728/5303634}\n */\nfunction convertTime12to24(time: string, ampm: string): string {\n  // eslint-disable-next-line prefer-const\n  let [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  if (hours === '12') hours = '00';\n  if (ampm === 'PM') hours = String(parseInt(hours, 10) + 12);\n\n  return `${hours}:${minutes}${seconds ? `:${seconds}` : ''}`;\n}\n\n/**\n * Normalizes a time string to have the following format: `hh:mm:ss`.\n */\nfunction normalizeTime(time: string): string {\n  const [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  return `${hours.padStart(2, '0')}:${minutes}:${seconds || '00'}`;\n}\n\n/**\n * Normalizes `am` / `a.m.` / etc. to `AM` (uppercase, no other characters).\n */\nfunction normalizeAMPM(ampm: string): string {\n  return ampm.replace(/[^apm]/gi, '').toUpperCase();\n}\n\nexport { regexSplitTime, convertTime12to24, normalizeTime, normalizeAMPM };\n","import { daysBeforeMonths, normalizeDate, orderDateComponents } from './date';\nimport {\n  regexSplitTime,\n  convertTime12to24,\n  normalizeAMPM,\n  normalizeTime,\n} from './time';\nimport { Attachment, Message, RawMessage, ParseStringOptions } from './types';\n\nconst regexParser =\n  /^(?:\\u200E|\\u200F)*\\[?(\\d{1,4}[-/.] ?\\d{1,4}[-/.] ?\\d{1,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.?\\s?m\\.?))?\\]?(?: -|:)? (.+?): ([^]*)/i;\nconst regexParserSystem =\n  /^(?:\\u200E|\\u200F)*\\[?(\\d{1,4}[-/.] ?\\d{1,4}[-/.] ?\\d{1,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.?\\s?m\\.?))?\\]?(?: -|:)? ([^]+)/i;\nconst regexAttachment = /<.+:(.+)>|([A-Z\\d-]+\\.\\w+)\\s\\(.+\\)/;\n\n/**\n * Takes an array of lines and detects the lines that are part of a previous\n * message (multiline messages) and merges them.\n *\n * It also labels messages without an author as system messages.\n */\nfunction makeArrayOfMessages(lines: string[]): RawMessage[] {\n  return lines.reduce((acc: RawMessage[], line) => {\n    /*\n     * If the line doesn't match the regex it's probably part of the previous\n     * message or a \"WhatsApp event\"\n     */\n    if (!regexParser.test(line)) {\n      /*\n       * If it doesn't match the first regex but still matches the system regex\n       * it should be considered a \"WhatsApp event\" so it gets labeled \"system\"\n       */\n      if (regexParserSystem.test(line)) {\n        acc.push({ system: true, msg: line });\n      }\n\n      // Else it's part of the previous message and it should be concatenated\n      else if (typeof acc[acc.length - 1] !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const prevMessage = acc.pop()!;\n\n        acc.push({\n          system: prevMessage.system,\n          msg: `${prevMessage.msg}\\n${line}`,\n        });\n      }\n    } else {\n      acc.push({ system: false, msg: line });\n    }\n\n    return acc;\n  }, []);\n}\n\n/**\n * Parses a message extracting the attachment if it's present.\n */\nfunction parseMessageAttachment(message: string): Attachment | null {\n  const attachmentMatch = message.match(regexAttachment);\n\n  if (!attachmentMatch) return null;\n  return {\n    fileName: (attachmentMatch[1] || attachmentMatch[2]).trim(),\n  };\n}\n\n/**\n * Parses and array of raw messages into an array of structured objects.\n */\nfunction parseMessages(\n  messages: RawMessage[],\n  options: ParseStringOptions = {},\n): Message[] {\n  let { daysFirst } = options;\n  const { parseAttachments } = options;\n\n  // Parse messages with regex\n  const parsed = messages.map(obj => {\n    const { system, msg } = obj;\n\n    // If it's a system message another regex should be used to parse it\n    if (system) {\n      const [, date, time, ampm, message] = regexParserSystem.exec(\n        msg,\n      ) as RegExpExecArray;\n\n      return { date, time, ampm: ampm || null, author: 'System', message };\n    }\n\n    const [, date, time, ampm, author, message] = regexParser.exec(\n      msg,\n    ) as RegExpExecArray;\n\n    return { date, time, ampm: ampm || null, author, message };\n  });\n\n  // Understand date format if not supplied (do days come first?)\n  if (typeof daysFirst !== 'boolean') {\n    const numericDates = Array.from(\n      new Set(parsed.map(({ date }) => date)),\n      date => orderDateComponents(date).map(Number),\n    );\n\n    daysFirst = daysBeforeMonths(numericDates);\n  }\n\n  // Convert date and time in a `Date` object, return the final object\n  return parsed.map(({ date, time, ampm, author, message }) => {\n    let day: string;\n    let month: string;\n    let year: string;\n    const splitDate = orderDateComponents(date);\n\n    if (daysFirst === false) {\n      [month, day, year] = splitDate;\n    } else {\n      [day, month, year] = splitDate;\n    }\n\n    [year, month, day] = normalizeDate(year, month, day);\n\n    const [hours, minutes, seconds] = normalizeTime(\n      ampm ? convertTime12to24(time, normalizeAMPM(ampm)) : time,\n    ).split(regexSplitTime);\n\n    const finalObject: Message = {\n      date: new Date(+year, +month - 1, +day, +hours, +minutes, +seconds),\n      author,\n      message,\n    };\n\n    // Optionally parse attachments\n    if (parseAttachments) {\n      const attachment = parseMessageAttachment(message);\n      if (attachment) finalObject.attachment = attachment;\n    }\n\n    return finalObject;\n  });\n}\n\nexport { makeArrayOfMessages, parseMessages };\n","import { makeArrayOfMessages, parseMessages } from './parser';\nimport { Message, ParseStringOptions } from './types';\n\nconst newlinesRegex = /(?:\\r\\n|\\r|\\n)/;\n\n/**\n * Parses a string containing a WhatsApp chat log.\n *\n * Returns a promise that will contain the parsed messages.\n *\n * @since 1.2.0\n */\nexport function parseString(\n  string: string,\n  options: ParseStringOptions = { parseAttachments: false },\n): Promise<Message[]> {\n  return Promise.resolve(string)\n    .then(data => data.split(newlinesRegex))\n    .then(makeArrayOfMessages)\n    .then(messages => parseMessages(messages, options));\n}\n\n/**\n * Parses a string containing a WhatsApp chat log.\n *\n * Returns an array of parsed messages.\n *\n * @since 3.2.0\n */\nexport function parseStringSync(\n  string: string,\n  options: ParseStringOptions = { parseAttachments: false },\n): Message[] {\n  const lines = string.split(newlinesRegex);\n  return parseMessages(makeArrayOfMessages(lines), options);\n}\n"],"names":["indexAboveValue","index","value","array","isNegative","number","checkDecreasing","numericDates","results","Object","values","reduce","obj","item","key","push","map","dates","slice","some","date","i","first1","first2","second1","second2","daysBeforeMonths","firstCheck","checkAbove12","secondCheck","diffs","num","j","Math","abs","first","second","total","diff","changeFrequencyAnalysis","orderDateComponents","a","b","c","split","maxLength","max","length","regexSplitTime","regexParser","regexParserSystem","regexAttachment","makeArrayOfMessages","lines","acc","line","test","system","msg","prevMessage","pop","parseMessages","messages","options","daysFirst","parseAttachments","parsed","time","ampm","message","exec","author","Array","from","Set","Number","day","month","year","splitDate","padStart","normalizeDate","hours","minutes","seconds","normalizeTime","String","parseInt","convertTime12to24","replace","toUpperCase","normalizeAMPM","finalObject","Date","attachment","attachmentMatch","match","fileName","trim","parseMessageAttachment","newlinesRegex","string","Promise","resolve","then","data"],"mappings":"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"}