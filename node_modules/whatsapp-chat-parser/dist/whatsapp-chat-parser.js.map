{"version":3,"file":"whatsapp-chat-parser.js","sources":["../src/utils.ts","../src/date.ts","../src/time.ts","../src/parser.ts","../src/index.ts"],"sourcesContent":["/**\n * Checks that the number at a certain index of an array is greater than a\n * certain value.\n */\nfunction indexAboveValue(index: number, value: number) {\n  return (array: number[]): boolean => array[index] > value;\n}\n\n/**\n * Returns `true` for a negative number, `false` otherwise.\n *\n * `0` and `-0` are considered positive.\n */\nfunction isNegative(number: number): boolean {\n  return number < 0;\n}\n\n/**\n * Takes an array of arrays and an index and groups the inner arrays by the\n * value at the index provided.\n * @see `utils.test.ts` for a better understanding of this function.\n */\nfunction groupArrayByValueAtIndex<T extends unknown[]>(\n  array: T[],\n  index: number,\n): T[][] {\n  return Object.values(\n    array.reduce((obj: { [key: string]: T[] }, item) => {\n      /*\n       * Keys that are numbers (even strings containing a number) get sorted\n       * when using `Object.values()`.\n       * Adding a prefix avoids this issue.\n       */\n      const key = `_${item[index]}`;\n\n      if (!obj[key]) obj[key] = [];\n\n      obj[key].push(item);\n\n      return obj;\n    }, {}),\n  );\n}\n\nexport { indexAboveValue, isNegative, groupArrayByValueAtIndex };\n","import { indexAboveValue, isNegative, groupArrayByValueAtIndex } from './utils';\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if numbers go above\n * `12`.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction checkAbove12(numericDates: number[][]): boolean | null {\n  const daysFirst = numericDates.some(indexAboveValue(0, 12));\n\n  if (daysFirst) return true;\n\n  const daysSecond = numericDates.some(indexAboveValue(1, 12));\n\n  if (daysSecond) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if a set of numbers\n * during the same year decrease at some point.\n *\n * If it does it's probably the days since months can only increase in a given\n * year.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction checkDecreasing(numericDates: number[][]): boolean | null {\n  const datesByYear = groupArrayByValueAtIndex(numericDates, 2);\n  const results = datesByYear.map(dates => {\n    const daysFirst = dates.slice(1).some((date, i) => {\n      const [first1] = dates[i];\n      const [first2] = date;\n\n      return isNegative(first2 - first1);\n    });\n\n    if (daysFirst) return true;\n\n    const daysSecond = dates.slice(1).some((date, i) => {\n      const [, second1] = dates[i];\n      const [, second2] = date;\n\n      return isNegative(second2 - second1);\n    });\n\n    if (daysSecond) return false;\n\n    return null;\n  });\n\n  const anyTrue = results.some(value => value === true);\n\n  if (anyTrue) return true;\n\n  const anyFalse = results.some(value => value === false);\n\n  if (anyFalse) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by looking at which number changes\n * more frequently.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction changeFrequencyAnalysis(numericDates: number[][]): boolean | null {\n  const diffs = numericDates\n    .slice(1)\n    .map((date, i) => date.map((num, j) => Math.abs(numericDates[i][j] - num)));\n  const [first, second] = diffs.reduce(\n    (total, diff) => {\n      const [first1, second1] = total;\n      const [first2, second2] = diff;\n\n      return [first1 + first2, second1 + second2];\n    },\n    [0, 0],\n  );\n\n  if (first > second) return true;\n  if (first < second) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by running the dates through various\n * checks.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction daysBeforeMonths(numericDates: number[][]): boolean | null {\n  const firstCheck = checkAbove12(numericDates);\n\n  if (firstCheck !== null) return firstCheck;\n\n  const secondCheck = checkDecreasing(numericDates);\n\n  if (secondCheck !== null) return secondCheck;\n\n  return changeFrequencyAnalysis(numericDates);\n}\n\n/**\n * Takes `year`, `month` and `day` as strings and pads them to `4`, `2`, `2`\n * digits respectively.\n */\nfunction normalizeDate(\n  year: string,\n  month: string,\n  day: string,\n): [string, string, string] {\n  return [\n    // 2 digit years are assumed to be in the 2000-2099 range\n    year.padStart(4, '2000'),\n    month.padStart(2, '0'),\n    day.padStart(2, '0'),\n  ];\n}\n\n/**\n * Pushes the longest number in a date to the end, if there is one. Necessary to\n * ensure the year is the last number.\n */\nfunction orderDateComponents(date: string): [string, string, string] {\n  const regexSplitDate = /[-/.] ?/;\n  const [a, b, c] = date.split(regexSplitDate);\n  const maxLength = Math.max(a.length, b.length, c.length);\n\n  if (c.length === maxLength) return [a, b, c];\n  if (b.length === maxLength) return [a, c, b];\n  return [b, c, a];\n}\n\nexport {\n  checkAbove12,\n  checkDecreasing,\n  changeFrequencyAnalysis,\n  daysBeforeMonths,\n  normalizeDate,\n  orderDateComponents,\n};\n","const regexSplitTime = /[:.]/;\n\n/**\n * Converts time from 12 hour format to 24 hour format.\n *\n * Reference:\n * {@link https://stackoverflow.com/a/40197728/5303634}\n */\nfunction convertTime12to24(time: string, ampm: string): string {\n  // eslint-disable-next-line prefer-const\n  let [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  if (hours === '12') hours = '00';\n  if (ampm === 'PM') hours = String(parseInt(hours, 10) + 12);\n\n  return `${hours}:${minutes}${seconds ? `:${seconds}` : ''}`;\n}\n\n/**\n * Normalizes a time string to have the following format: `hh:mm:ss`.\n */\nfunction normalizeTime(time: string): string {\n  const [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  return `${hours.padStart(2, '0')}:${minutes}:${seconds || '00'}`;\n}\n\n/**\n * Normalizes `am` / `a.m.` / etc. to `AM` (uppercase, no other characters).\n */\nfunction normalizeAMPM(ampm: string): string {\n  return ampm.replace(/[^apm]/gi, '').toUpperCase();\n}\n\nexport { regexSplitTime, convertTime12to24, normalizeTime, normalizeAMPM };\n","import { daysBeforeMonths, normalizeDate, orderDateComponents } from './date';\nimport {\n  regexSplitTime,\n  convertTime12to24,\n  normalizeAMPM,\n  normalizeTime,\n} from './time';\nimport { Attachment, Message, RawMessage, ParseStringOptions } from './types';\n\nconst regexParser =\n  /^(?:\\u200E|\\u200F)*\\[?(\\d{1,4}[-/.] ?\\d{1,4}[-/.] ?\\d{1,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.?\\s?m\\.?))?\\]?(?: -|:)? (.+?): ([^]*)/i;\nconst regexParserSystem =\n  /^(?:\\u200E|\\u200F)*\\[?(\\d{1,4}[-/.] ?\\d{1,4}[-/.] ?\\d{1,4})[,.]? \\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?: ([ap]\\.?\\s?m\\.?))?\\]?(?: -|:)? ([^]+)/i;\nconst regexAttachment = /<.+:(.+)>|([A-Z\\d-]+\\.\\w+)\\s\\(.+\\)/;\n\n/**\n * Takes an array of lines and detects the lines that are part of a previous\n * message (multiline messages) and merges them.\n *\n * It also labels messages without an author as system messages.\n */\nfunction makeArrayOfMessages(lines: string[]): RawMessage[] {\n  return lines.reduce((acc: RawMessage[], line) => {\n    /*\n     * If the line doesn't match the regex it's probably part of the previous\n     * message or a \"WhatsApp event\"\n     */\n    if (!regexParser.test(line)) {\n      /*\n       * If it doesn't match the first regex but still matches the system regex\n       * it should be considered a \"WhatsApp event\" so it gets labeled \"system\"\n       */\n      if (regexParserSystem.test(line)) {\n        acc.push({ system: true, msg: line });\n      }\n\n      // Else it's part of the previous message and it should be concatenated\n      else if (typeof acc[acc.length - 1] !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const prevMessage = acc.pop()!;\n\n        acc.push({\n          system: prevMessage.system,\n          msg: `${prevMessage.msg}\\n${line}`,\n        });\n      }\n    } else {\n      acc.push({ system: false, msg: line });\n    }\n\n    return acc;\n  }, []);\n}\n\n/**\n * Parses a message extracting the attachment if it's present.\n */\nfunction parseMessageAttachment(message: string): Attachment | null {\n  const attachmentMatch = message.match(regexAttachment);\n\n  if (!attachmentMatch) return null;\n  return {\n    fileName: (attachmentMatch[1] || attachmentMatch[2]).trim(),\n  };\n}\n\n/**\n * Parses and array of raw messages into an array of structured objects.\n */\nfunction parseMessages(\n  messages: RawMessage[],\n  options: ParseStringOptions = {},\n): Message[] {\n  let { daysFirst } = options;\n  const { parseAttachments } = options;\n\n  // Parse messages with regex\n  const parsed = messages.map(obj => {\n    const { system, msg } = obj;\n\n    // If it's a system message another regex should be used to parse it\n    if (system) {\n      const [, date, time, ampm, message] = regexParserSystem.exec(\n        msg,\n      ) as RegExpExecArray;\n\n      return { date, time, ampm: ampm || null, author: 'System', message };\n    }\n\n    const [, date, time, ampm, author, message] = regexParser.exec(\n      msg,\n    ) as RegExpExecArray;\n\n    return { date, time, ampm: ampm || null, author, message };\n  });\n\n  // Understand date format if not supplied (do days come first?)\n  if (typeof daysFirst !== 'boolean') {\n    const numericDates = Array.from(\n      new Set(parsed.map(({ date }) => date)),\n      date => orderDateComponents(date).map(Number),\n    );\n\n    daysFirst = daysBeforeMonths(numericDates);\n  }\n\n  // Convert date and time in a `Date` object, return the final object\n  return parsed.map(({ date, time, ampm, author, message }) => {\n    let day: string;\n    let month: string;\n    let year: string;\n    const splitDate = orderDateComponents(date);\n\n    if (daysFirst === false) {\n      [month, day, year] = splitDate;\n    } else {\n      [day, month, year] = splitDate;\n    }\n\n    [year, month, day] = normalizeDate(year, month, day);\n\n    const [hours, minutes, seconds] = normalizeTime(\n      ampm ? convertTime12to24(time, normalizeAMPM(ampm)) : time,\n    ).split(regexSplitTime);\n\n    const finalObject: Message = {\n      date: new Date(+year, +month - 1, +day, +hours, +minutes, +seconds),\n      author,\n      message,\n    };\n\n    // Optionally parse attachments\n    if (parseAttachments) {\n      const attachment = parseMessageAttachment(message);\n      if (attachment) finalObject.attachment = attachment;\n    }\n\n    return finalObject;\n  });\n}\n\nexport { makeArrayOfMessages, parseMessages };\n","import { makeArrayOfMessages, parseMessages } from './parser';\nimport { Message, ParseStringOptions } from './types';\n\nconst newlinesRegex = /(?:\\r\\n|\\r|\\n)/;\n\n/**\n * Parses a string containing a WhatsApp chat log.\n *\n * Returns a promise that will contain the parsed messages.\n *\n * @since 1.2.0\n */\nexport function parseString(\n  string: string,\n  options: ParseStringOptions = { parseAttachments: false },\n): Promise<Message[]> {\n  return Promise.resolve(string)\n    .then(data => data.split(newlinesRegex))\n    .then(makeArrayOfMessages)\n    .then(messages => parseMessages(messages, options));\n}\n\n/**\n * Parses a string containing a WhatsApp chat log.\n *\n * Returns an array of parsed messages.\n *\n * @since 3.2.0\n */\nexport function parseStringSync(\n  string: string,\n  options: ParseStringOptions = { parseAttachments: false },\n): Message[] {\n  const lines = string.split(newlinesRegex);\n  return parseMessages(makeArrayOfMessages(lines), options);\n}\n"],"names":[],"mappings":"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"}